$date
  Thu Apr  2 19:44:03 2020
$end
$version
  GHDL v0
$end
$timescale
  1 fs
$end
$scope module standard $end
$upscope $end
$scope module std_logic_1164 $end
$upscope $end
$scope module numeric_std $end
$upscope $end
$scope module t_top $end
$var reg 1 ! clk_t $end
$var reg 1 " reset_t $end
$var reg 1 # instructionwriteenable_t $end
$var reg 16 $ instructionwriteaddr_t[15:0] $end
$var reg 16 % instructionwritedata_t[15:0] $end
$var reg 16 & startpc_t[15:0] $end
$var reg 16 ' instructionout_t[15:0] $end
$var reg 4 ( inr_t[3:0] $end
$var reg 16 ) outr_t[15:0] $end
$scope module test $end
$var reg 1 * clk $end
$var reg 1 + instructionwriteenable $end
$var reg 16 , instructionwriteaddr[15:0] $end
$var reg 16 - instructionwritedata[15:0] $end
$var reg 16 . startpc[15:0] $end
$var reg 16 / instructionout[15:0] $end
$var reg 4 0 inr[3:0] $end
$var reg 16 1 outr[15:0] $end
$var reg 1 2 reset $end
$var reg 1 3 clk_t $end
$var reg 1 4 reset_t $end
$var reg 1 5 andbranch_t $end
$var reg 1 6 instructionwriteenable_t $end
$var reg 16 7 instructionwriteaddr_t[15:0] $end
$var reg 16 8 instructionwritedata_t[15:0] $end
$var reg 4 9 inr_t[3:0] $end
$var reg 16 : outr_t[15:0] $end
$var reg 16 ; instruction_t[15:0] $end
$var reg 1 < cregwrite_t $end
$var reg 1 = cldi_t $end
$var reg 1 > cjalr_t $end
$var reg 16 ? writeinput_t[15:0] $end
$var reg 16 @ pcinput_t[15:0] $end
$var reg 16 A r1tooffsetmux_t[15:0] $end
$var reg 16 B registertomemory_t[15:0] $end
$var reg 16 C pcoutput_t[15:0] $end
$var reg 4 D caluop_t[3:0] $end
$var reg 16 E a_t[15:0] $end
$var reg 16 F b_t[15:0] $end
$var reg 1 G isbranch_t $end
$var reg 10 H alutomemory_t[9:0] $end
$var reg 16 I alutoregmux_t[15:0] $end
$var reg 16 J outmemory_t[15:0] $end
$var reg 16 K signextension_t[15:0] $end
$var reg 16 L branchadderoutput_t[15:0] $end
$var reg 16 M incrementadderoutput_t[15:0] $end
$var reg 1 N coffset_t $end
$var reg 1 O cmemtoreg_t $end
$var reg 1 P cmemwrite_t $end
$var reg 1 Q cmemread_t $end
$var reg 1 R cisbranch_t $end
$var reg 1 S carry_t $end
$scope module rf $end
$var reg 1 T clk $end
$var reg 4 U rd[11:8] $end
$var reg 4 V r1[7:4] $end
$var reg 4 W r2[3:0] $end
$var reg 1 X cregwrite $end
$var reg 1 Y cldi $end
$var reg 1 Z cjalr $end
$var reg 16 [ writeinput[15:0] $end
$var reg 16 \ outr1tooffsetmux[15:0] $end
$var reg 16 ] outr2toalu[15:0] $end
$var reg 16 ^ tomemory[15:0] $end
$var reg 16 _ pcoutput[15:0] $end
$var reg 16 ` pcinput[15:0] $end
$var reg 4 a inr[3:0] $end
$var reg 16 b outr[15:0] $end
$var reg 1 c reset $end
$comment register16 is not handled $end
$upscope $end
$scope module arithmetic $end
$var reg 1 d clk $end
$var reg 4 e aluop[3:0] $end
$var reg 16 f a[15:0] $end
$var reg 16 g b[15:0] $end
$var reg 1 h isbranch $end
$var reg 10 i outtomemory[9:0] $end
$var reg 16 j outtoregmux[15:0] $end
$var reg 1 k reset $end
$upscope $end
$scope module control $end
$var reg 4 l opcode[15:12] $end
$var reg 1 m cregwrite $end
$var reg 1 n coffset $end
$var reg 4 o caluop[3:0] $end
$var reg 1 p cmemwrite $end
$var reg 1 q cmemread $end
$var reg 1 r cmemtoreg $end
$var reg 1 s cldi $end
$var reg 1 t cjalr $end
$var reg 1 u cisbranch $end
$var reg 1 v reset $end
$upscope $end
$scope module sign $end
$var reg 8 w input[7:0] $end
$var reg 16 x output[15:0] $end
$var reg 1 y reset $end
$upscope $end
$scope module incrementadder $end
$var reg 16 z a[15:0] $end
$var reg 16 { b[15:0] $end
$var reg 16 | sum[15:0] $end
$var reg 1 } cout $end
$var reg 1 !" reset $end
$var reg 17 "" result[16:0] $end
$upscope $end
$scope module branchadder $end
$var reg 16 #" a[15:0] $end
$var reg 16 $" b[15:0] $end
$var reg 16 %" sum[15:0] $end
$var reg 1 &" cout $end
$var reg 1 '" reset $end
$var reg 17 (" result[16:0] $end
$upscope $end
$scope module offsetmux $end
$var reg 16 )" a1[15:0] $end
$var reg 16 *" a2[15:0] $end
$var reg 1 +" sel $end
$var reg 16 ," b[15:0] $end
$upscope $end
$scope module pcmux $end
$var reg 16 -" a1[15:0] $end
$var reg 16 ." a2[15:0] $end
$var reg 1 /" sel $end
$var reg 16 0" b[15:0] $end
$upscope $end
$scope module regmux $end
$var reg 16 1" a1[15:0] $end
$var reg 16 2" a2[15:0] $end
$var reg 1 3" sel $end
$var reg 16 4" b[15:0] $end
$upscope $end
$scope module instruction $end
$var reg 1 5" clk $end
$var reg 16 6" pc[15:0] $end
$var reg 1 7" writeenable $end
$var reg 16 8" writedata[15:0] $end
$var reg 16 9" outinstruction[15:0] $end
$var reg 1 :" reset $end
$comment instruction65536 is not handled $end
$upscope $end
$scope module disk $end
$var reg 10 ;" addr[9:0] $end
$var reg 16 <" din[15:0] $end
$var reg 1 =" cmemwrite $end
$var reg 1 >" cmemread $end
$var reg 16 ?" outmemory[15:0] $end
$var reg 1 @" reset $end
$comment memory1024 is not handled $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
0!
1"
U#
bUUUUUUUUUUUUUUUU $
bUUUUUUUUUUUUUUUU %
bUUUUUUUUUUUUUUUU &
b0000000000000000 '
bUUUU (
b0000000000000000 )
0*
U+
bUUUUUUUUUUUUUUUU ,
bUUUUUUUUUUUUUUUU -
bUUUUUUUUUUUUUUUU .
b0000000000000000 /
bUUUU 0
b0000000000000000 1
12
03
14
05
U6
bUUUUUUUUUUUUUUUU 7
bUUUUUUUUUUUUUUUU 8
bUUUU 9
b0000000000000000 :
b0000000000000000 ;
0<
0=
0>
b0000000000000000 ?
b0000000000000000 @
b0000000000000000 A
b0000000000000000 B
b0000000000000000 C
b0000 D
b0000000000000000 E
b0000000000000000 F
0G
b0000000000 H
b0000000000000000 I
b0000000000000000 J
b0000000000000000 K
b0000000000000000 L
b0000000000000000 M
0N
0O
0P
0Q
0R
0S
0T
b0000 U
b0000 V
b0000 W
0X
0Y
0Z
b0000000000000000 [
b0000000000000000 \
b0000000000000000 ]
b0000000000000000 ^
b0000000000000000 _
b0000000000000000 `
bUUUU a
b0000000000000000 b
1c
0d
b0000 e
b0000000000000000 f
b0000000000000000 g
0h
b0000000000 i
b0000000000000000 j
1k
b0000 l
0m
0n
b0000 o
0p
0q
0r
0s
0t
0u
1v
b00000000 w
b0000000000000000 x
1y
b0000000000000001 z
b0000000000000000 {
b0000000000000000 |
0}
1!"
b00000000000000000 ""
b0000000000000000 #"
b0000000000000000 $"
b0000000000000000 %"
0&"
1'"
b00000000000000000 ("
b0000000000000000 )"
b0000000000000000 *"
0+"
b0000000000000000 ,"
b0000000000000000 -"
b0000000000000000 ."
0/"
b0000000000000000 0"
b0000000000000000 1"
b0000000000000000 2"
03"
b0000000000000000 4"
05"
b0000000000000000 6"
U7"
bUUUUUUUUUUUUUUUU 8"
b0000000000000000 9"
1:"
b0000000000 ;"
b0000000000000000 <"
0="
0>"
b0000000000000000 ?"
1@"
#5000000
1!
1*
13
1T
1d
15"
#10000000
0!
0"
b0000000000000000 &
b0010011000000011 '
b0000 (
0*
b0000000000000000 .
b0010011000000011 /
b0000 0
02
03
04
b0000 9
b0010011000000011 ;
1<
1=
b0000000000000001 @
b0010 D
b0000000000000011 K
b0000000000000011 L
b0000000000000001 M
XO
0T
b0110 U
b0011 W
1X
1Y
b0000000000000001 `
b0000 a
0c
0d
b0010 e
0k
b0010 l
1m
b0010 o
Xr
1s
0v
b00000011 w
b0000000000000011 x
0y
b0000000000000001 |
0}
0!"
b00000000000000001 ""
b0000000000000011 $"
b0000000000000011 %"
0&"
0'"
b00000000000000011 ("
b0000000000000011 *"
b0000000000000001 -"
b0000000000000011 ."
b0000000000000001 0"
X3"
05"
b0000000000000001 6"
b0010011000000011 9"
0:"
0@"
#15000000
1!
1*
13
1T
1d
15"
#20000000
0!
b0010011100000111 '
b0001 (
0*
b0010011100000111 /
b0001 0
03
b0001 9
b0010011100000111 ;
b0000000000000010 @
b0000000000000001 C
b0000000000000111 K
b0000000000001000 L
b0000000000000010 M
0T
b0111 U
b0111 W
b0000000000000001 _
b0000000000000010 `
b0001 a
0d
b00000111 w
b0000000000000111 x
b0000000000000001 {
b0000000000000010 |
0}
b00000000000000010 ""
b0000000000000001 #"
b0000000000000111 $"
b0000000000001000 %"
0&"
b00000000000001000 ("
b0000000000000111 *"
b0000000000000010 -"
b0000000000001000 ."
b0000000000000010 0"
05"
b0000000000000010 6"
b0010011100000111 9"
#25000000
1!
1*
13
b0000000000000111 F
1T
b0000000000000111 ]
1d
b0000000000000111 g
15"
#30000000
0!
b0100100001100000 '
b0010 (
0*
b0100100001100000 /
b0010 0
03
b0010 9
b0100100001100000 ;
0=
b0000000000000011 ?
b0000000000000011 @
b0000000000000011 A
b0000000000000011 B
b0000000000000010 C
b0100 D
b0000000000000011 E
b0000000000000000 F
b0000000000000011 I
b0000000000000011 J
b0000000001100000 K
b0000000001100010 L
b0000000000000011 M
0O
0T
b1000 U
b0110 V
b0000 W
0Y
b0000000000000011 [
b0000000000000011 \
b0000000000000000 ]
b0000000000000011 ^
b0000000000000010 _
b0000000000000011 `
b0010 a
0d
b0100 e
b0000000000000011 f
b0000000000000000 g
b0000000000000011 j
b0100 l
b0100 o
0r
0s
b01100000 w
b0000000001100000 x
b0000000000000010 {
b0000000000000011 |
0}
b00000000000000011 ""
b0000000000000010 #"
b0000000001100000 $"
b0000000001100010 %"
0&"
b00000000001100010 ("
b0000000000000011 )"
b0000000001100000 *"
b0000000000000011 ,"
b0000000000000011 -"
b0000000001100010 ."
b0000000000000011 0"
b0000000000000011 1"
b0000000000000011 2"
03"
b0000000000000011 4"
05"
b0000000000000011 6"
b0100100001100000 9"
b0000000000000011 <"
b0000000000000011 ?"
#35000000
1!
1*
13
1T
1d
15"
#40000000
0!
b0101010101111000 '
b0011 (
0*
b0101010101111000 /
b0011 0
03
b0011 9
b0101010101111000 ;
b0000000000001010 ?
b0000000000000100 @
b0000000000000111 A
b0000000000000111 B
b0000000000000011 C
b0101 D
b0000000000000111 E
b0000000000000011 F
b0000000000001010 I
b0000000000000111 J
b0000000001111000 K
b0000000001111011 L
b0000000000000100 M
0T
b0101 U
b0111 V
b1000 W
b0000000000001010 [
b0000000000000111 \
b0000000000000011 ]
b0000000000000111 ^
b0000000000000011 _
b0000000000000100 `
b0011 a
0d
b0101 e
b0000000000000111 f
b0000000000000011 g
b0000000000001010 j
b0101 l
b0101 o
b01111000 w
b0000000001111000 x
b0000000000000011 {
b0000000000000100 |
0}
b00000000000000100 ""
b0000000000000011 #"
b0000000001111000 $"
b0000000001111011 %"
0&"
b00000000001111011 ("
b0000000000000111 )"
b0000000001111000 *"
b0000000000000111 ,"
b0000000000000100 -"
b0000000001111011 ."
b0000000000000100 0"
b0000000000001010 1"
b0000000000000111 2"
b0000000000001010 4"
05"
b0000000000000100 6"
b0101010101111000 9"
b0000000000000111 <"
b0000000000000111 ?"
#45000000
1!
1*
13
1T
1d
15"
