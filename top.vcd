$date
  Thu Apr  2 16:19:59 2020
$end
$version
  GHDL v0
$end
$timescale
  1 fs
$end
$scope module standard $end
$upscope $end
$scope module std_logic_1164 $end
$upscope $end
$scope module numeric_std $end
$upscope $end
$scope module t_top $end
$var reg 1 ! clk_t $end
$var reg 1 " reset_t $end
$var reg 16 # instructionout_t[15:0] $end
$var reg 4 $ inr_t[3:0] $end
$var reg 16 % outr_t[15:0] $end
$scope module test $end
$var reg 1 & clk $end
$var reg 16 ' instructionout[15:0] $end
$var reg 4 ( inr[3:0] $end
$var reg 16 ) outr[15:0] $end
$var reg 1 * reset $end
$var reg 1 + clk_t $end
$var reg 1 , reset_t $end
$var reg 16 - pc_t[15:0] $end
$var reg 4 . inr_t[3:0] $end
$var reg 16 / outr_t[15:0] $end
$var reg 16 0 instruction_t[15:0] $end
$var reg 1 1 cregwrite_t $end
$var reg 1 2 cldi_t $end
$var reg 1 3 cjalr_t $end
$var reg 16 4 writeinput_t[15:0] $end
$var reg 16 5 r1tooffsetmux_t[15:0] $end
$var reg 16 6 registertomemory_t[15:0] $end
$var reg 4 7 caluop_t[3:0] $end
$var reg 16 8 a_t[15:0] $end
$var reg 16 9 b_t[15:0] $end
$var reg 1 : isbranch_t $end
$var reg 10 ; alutomemory_t[9:0] $end
$var reg 16 < alutoregmux_t[15:0] $end
$var reg 16 = outmemory_t[15:0] $end
$var reg 16 > signextension_t[15:0] $end
$var reg 16 ? branchadderoutput_t[15:0] $end
$var reg 16 @ incrementadderoutput_t[15:0] $end
$var reg 1 A coffset_t $end
$var reg 1 B cmemtoreg_t $end
$var reg 1 C cmemwrite_t $end
$var reg 1 D cmemread_t $end
$var reg 1 E carry_t $end
$scope module rf $end
$var reg 1 F clk $end
$var reg 4 G rd[11:8] $end
$var reg 4 H r1[7:4] $end
$var reg 4 I r2[3:0] $end
$var reg 1 J cregwrite $end
$var reg 1 K cldi $end
$var reg 1 L cjalr $end
$var reg 16 M writeinput[15:0] $end
$var reg 16 N outr1tooffsetmux[15:0] $end
$var reg 16 O outr2toalu[15:0] $end
$var reg 16 P tomemory[15:0] $end
$var reg 4 Q inr[3:0] $end
$var reg 16 R outr[15:0] $end
$var reg 1 S reset $end
$comment register16 is not handled $end
$upscope $end
$scope module arithmetic $end
$var reg 1 T clk $end
$var reg 4 U aluop[3:0] $end
$var reg 16 V a[15:0] $end
$var reg 16 W b[15:0] $end
$var reg 1 X isbranch $end
$var reg 10 Y outtomemory[9:0] $end
$var reg 16 Z outtoregmux[15:0] $end
$var reg 1 [ reset $end
$upscope $end
$scope module control $end
$var reg 4 \ opcode[15:12] $end
$var reg 1 ] cregwrite $end
$var reg 1 ^ coffset $end
$var reg 4 _ caluop[3:0] $end
$var reg 1 ` cmemwrite $end
$var reg 1 a cmemread $end
$var reg 1 b cmemtoreg $end
$var reg 1 c cldi $end
$var reg 1 d cjalr $end
$var reg 1 e reset $end
$upscope $end
$scope module sign $end
$var reg 8 f input[7:0] $end
$var reg 16 g output[15:0] $end
$var reg 1 h reset $end
$upscope $end
$scope module incrementadder $end
$var reg 16 i a[15:0] $end
$var reg 16 j b[15:0] $end
$var reg 16 k sum[15:0] $end
$var reg 1 l cout $end
$var reg 1 m reset $end
$var reg 17 n result[16:0] $end
$upscope $end
$scope module branchadder $end
$var reg 16 o a[15:0] $end
$var reg 16 p b[15:0] $end
$var reg 16 q sum[15:0] $end
$var reg 1 r cout $end
$var reg 1 s reset $end
$var reg 17 t result[16:0] $end
$upscope $end
$scope module offsetmux $end
$var reg 16 u a1[15:0] $end
$var reg 16 v a2[15:0] $end
$var reg 1 w sel $end
$var reg 16 x b[15:0] $end
$upscope $end
$scope module pcmux $end
$var reg 16 y a1[15:0] $end
$var reg 16 z a2[15:0] $end
$var reg 1 { sel $end
$var reg 16 | b[15:0] $end
$upscope $end
$scope module regmux $end
$var reg 16 } a1[15:0] $end
$var reg 16 !" a2[15:0] $end
$var reg 1 "" sel $end
$var reg 16 #" b[15:0] $end
$upscope $end
$scope module instruction $end
$var reg 1 $" clk $end
$var reg 16 %" pc[15:0] $end
$var reg 16 &" outinstruction[15:0] $end
$var reg 1 '" reset $end
$comment instruction65536 is not handled $end
$upscope $end
$scope module disk $end
$var reg 10 (" addr[9:0] $end
$var reg 16 )" din[15:0] $end
$var reg 1 *" cmemwrite $end
$var reg 1 +" cmemread $end
$var reg 16 ," outmemory[15:0] $end
$var reg 1 -" reset $end
$comment memory1024 is not handled $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
0!
1"
b0000000000000000 #
bUUUU $
b0000000000000000 %
0&
b0000000000000000 '
bUUUU (
b0000000000000000 )
1*
0+
1,
b0000000000000000 -
bUUUU .
b0000000000000000 /
b0000000000000000 0
01
02
03
b0000000000000000 4
b0000000000000000 5
b0000000000000000 6
b0000 7
b0000000000000000 8
b0000000000000000 9
0:
b0000000000 ;
b0000000000000000 <
b0000000000000000 =
b0000000000000000 >
b0000000000000000 ?
b0000000000000000 @
0A
0B
0C
0D
0E
0F
b0000 G
b0000 H
b0000 I
0J
0K
0L
b0000000000000000 M
b0000000000000000 N
b0000000000000000 O
b0000000000000000 P
bUUUU Q
b0000000000000000 R
1S
0T
b0000 U
b0000000000000000 V
b0000000000000000 W
0X
b0000000000 Y
b0000000000000000 Z
1[
b0000 \
0]
0^
b0000 _
0`
0a
0b
0c
0d
1e
b00000000 f
b0000000000000000 g
1h
b0000000000000001 i
b0000000000000000 j
b0000000000000000 k
0l
1m
b00000000000000000 n
b0000000000000000 o
b0000000000000000 p
b0000000000000000 q
0r
1s
b00000000000000000 t
b0000000000000000 u
b0000000000000000 v
0w
b0000000000000000 x
b0000000000000000 y
b0000000000000000 z
0{
b0000000000000000 |
b0000000000000000 }
b0000000000000000 !"
0""
b0000000000000000 #"
0$"
b0000000000000000 %"
b0000000000000000 &"
1'"
b0000000000 ("
b0000000000000000 )"
0*"
0+"
b0000000000000000 ,"
1-"
#5000000
1!
1&
1+
1F
1T
1$"
