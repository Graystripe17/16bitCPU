$date
  Sun Mar 29 10:19:46 2020
$end
$version
  GHDL v0
$end
$timescale
  1 fs
$end
$scope module standard $end
$upscope $end
$scope module std_logic_1164 $end
$upscope $end
$scope module top $end
$var reg 1 ! clk $end
$var reg 4 " inr[3:0] $end
$var reg 16 # outvalue[15:0] $end
$var reg 1 $ reset $end
$var reg 1 % reset_t $end
$var reg 4 & inr_t[3:0] $end
$var reg 16 ' outvalue_t[15:0] $end
$var reg 1 ( clk_t $end
$var reg 16 ) instruction_t[15:0] $end
$var reg 1 * cregwrite_t $end
$var reg 1 + cldi_t $end
$var reg 1 , cjalr_t $end
$var reg 16 - writeinput_t[15:0] $end
$var reg 16 . pcinput_t[15:0] $end
$var reg 16 / r1tooffsetmux_t[15:0] $end
$var reg 16 0 r2toalu_t[15:0] $end
$var reg 16 1 registertomemory_t[15:0] $end
$var reg 16 2 pcoutput_t[15:0] $end
$var reg 4 3 caluop_t[3:0] $end
$var reg 16 4 a_t[15:0] $end
$var reg 16 5 b_t[15:0] $end
$var reg 1 6 isbranch_t $end
$var reg 10 7 alutomemory_t[9:0] $end
$var reg 16 8 alutoregmux_t[15:0] $end
$var reg 16 9 memoryout_t[15:0] $end
$var reg 16 : signextension_t[15:0] $end
$var reg 16 ; branchadderoutput_t[15:0] $end
$var reg 16 < incrementadderoutput_t[15:0] $end
$var reg 1 = coffset_t $end
$var reg 1 > cmemtoreg_t $end
$var reg 1 ? carry_t $end
$scope module rf $end
$upscope $end
$scope module arithmetic $end
$upscope $end
$scope module sign $end
$upscope $end
$scope module incrementadder $end
$upscope $end
$scope module branchadder $end
$upscope $end
$scope module offsetmux $end
$upscope $end
$scope module pcmux $end
$upscope $end
$scope module instruction $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
U!
bUUUU "
bUUUUUUUUUUUUUUUU #
U$
U%
bUUUU &
bUUUUUUUUUUUUUUUU '
U(
bUUUUUUUUUUUUUUUU )
U*
U+
U,
bUUUUUUUUUUUUUUUU -
bUUUUUUUUUUUUUUUU .
bUUUUUUUUUUUUUUUU /
bUUUUUUUUUUUUUUUU 0
b0000000000000000 1
bUUUUUUUUUUUUUUUU 2
b0000 3
bUUUUUUUUUUUUUUUU 4
b0000000000000000 5
06
b0000000000 7
b0000000000000000 8
bUUUUUUUUUUUUUUUU 9
bUUUUUUUUUUUUUUUU :
bUUUUUUUUUUUUUUUU ;
bUUUUUUUUUUUUUUUU <
U=
U>
U?
